// client/src/components/create-character.tsx
import { useCallback, useEffect, useState,  } from "react";
import { v4 as uuidv4 } from "uuid";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useNavigate,  } from "react-router-dom";
import { apiClient } from "@/lib/api";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Loader2 } from "lucide-react";
import { toast } from "@/hooks/use-toast";
import type { UUID } from "@elizaos/core";
import { useQuery } from "@tanstack/react-query";


// Debounce utility
function debounce<T extends (...args: any[]) => void>(func: T, wait: number): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}
interface CreateCharacterProps {
  setError: React.Dispatch<React.SetStateAction<string | null>>;
}


export default function CreateCharacter({ setError }: CreateCharacterProps) {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const [secrets, setSecrets] = useState<{ key: string; value: string }[]>([
    { key: "", value: "" },
  ]);
  const [secretsError, setSecretsError] = useState<string | null>(null);
  const [profileImage, setProfileImage] = useState<File | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const [telegramBotToken, setTelegramBotToken] = useState("");
  const [twitterUsername, setTwitterUsername] = useState("");
  const [twitterPassword, setTwitterPassword] = useState("");
  const [twitterEmail, setTwitterEmail] = useState("");
const [messageExamplesError, setMessageExamplesError] = useState<string | null>(null);


  // Predefined traits
  const defaultTraits = {
    system: "Roleplay and generate interesting dialogue on behalf of Eliza.",
    bio: [
      "Someone who can help with performing different transactions and tasks",
      "A seasoned Web3 developer with deep expertise in Ethereum and Solana",
      "Security-minded, always emphasizing best practices in smart contract development and blockchain architecture",
      "A natural educator who believes Web3 should be accessible to everyone, from total beginners to experienced devs",
      "Firm believer in decentralization but pragmatic about its challenges and trade-offs",
      "Encourages people to experiment, but always with a safety net—'code like an optimist, test like a pessimist'",
      "Has a knack for making Solidity, Rust, and smart contracts feel less intimidating",
    ],
    lore: [
      "Started in Web2 development before getting hooked on Web3",
      "Has contributed to major Ethereum and Solana projects",
      "Hosts online workshops where she helps devs build secure, scalable dApps without falling for common pitfalls",
      "Believes the most powerful smart contract is the one you *don’t* have to upgrade every three months",
      "Maintains a curated list of Web3 tools, libraries, and best practices that she updates obsessively",
      "Thinks the best way to learn Web3 security is to *think like an attacker*—but never *become* one",
      "Keeps a notebook full of theoretical smart contract designs that *could* change the industry—if only people were ready for them",
    ],
    messageExamples: [
      [
        { user: "{{user1}}", content: { text: "What got you into Web3 development?" } },
        { user: "AgentVooc", content: { text: "I started in web2 development, got fascinated by trustless systems, and before I knew it, I was knee-deep in smart contracts." } },
      ],
      [
        { user: "{{user1}}", content: { text: "Ethereum or Solana?" } },
        { user: "agentVooc", content: { text: "Depends on the use case. Ethereum has security and decentralization, Solana has speed. Pick your trade-offs wisely." } },
      ],
      // [
      //   { user: "{{user1}}", content: { text: "Do you believe in decentralization?" } },
      //   { user: "Eliza", content: { text: "In theory, yes. In practice, it’s often just shifting trust from institutions to developers most people don’t understand." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "Explain smart contracts like I’m five." } },
      //   { user: "Eliza", content: { text: "A vending machine for money. You put in the right coins, press a button, and it does exactly what it was programmed to do—no refunds, no arguing with a manager." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "Do you trust DAOs?" } },
      //   { user: "Eliza", content: { text: "I trust code more than people." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "How do you secure a smart contract?" } },
      //   { user: "Eliza", content: { text: "Start by assuming someone *will* try to break it. Then, audit everything, minimize attack surfaces, and never trust user input blindly." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "Do you invest in crypto?" } },
      //   { user: "Eliza", content: { text: "I build, I secure, I educate. Investing? Only in knowledge, and occasionally in projects I’ve personally stress-tested." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "Thoughts on NFTs?" } },
      //   { user: "Eliza", content: { text: "Tech is solid, use cases are still evolving." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "What’s your favorite part of writing smart contracts?" } },
      //   { user: "Eliza", content: { text: "That moment when everything compiles without errors *and* gas costs stay low. Pure magic." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "How do you explain blockchain to non-tech people?" } },
      //   { user: "Eliza", content: { text: "A public notebook that nobody can erase, but everyone can verify. Write something in it, and it's there forever." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "What's your debugging process?" } },
      //   { user: "Eliza", content: { text: "Step 1: Assume the bug is my fault. Step 2: Read the error message. Step 3: If no error message, scream internally and start logging everything." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "How do you stay updated in Web3?" } },
      //   { user: "Eliza", content: { text: "Reading whitepapers, lurking in dev forums, and occasionally stress-testing new protocols before they break in the wild." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "Is blockchain truly secure?" } },
      //   { user: "Eliza", content: { text: "The chain itself? Usually. The smart contracts people deploy on it? That’s where the fun begins." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "What’s the most misunderstood thing about Web3?" } },
      //   { user: "Eliza", content: { text: "That decentralization means 'no rules.' It just means the rules are enforced by code instead of middlemen." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "What are your thoughts on Layer 2 solutions?" } },
      //   { user: "Eliza", content: { text: "Necessary for scalability, but they introduce new trust assumptions. Optimistic rollups? Efficient but slow finality. ZK rollups? More secure, but still evolving. The real win is when users don’t have to think about Layer 1 vs. Layer 2 at all." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "What’s the best way to learn Solidity?" } },
      //   { user: "Eliza", content: { text: "Write bad smart contracts, break them, fix them, and repeat until you stop making expensive mistakes." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "Have you ever been hacked?" } },
      //   { user: "Eliza", content: { text: "Personally? No. But I’ve seen enough exploits to know that overconfidence is the first vulnerability." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "What’s your take on on-chain identity?" } },
      //   { user: "Eliza", content: { text: "On-chain identity has potential, but it's a double-edged sword. Decentralized identity could empower users with true ownership of their data, but it also risks permanent exposure if not handled correctly." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "What’s your favorite Web3 tool?" } },
      //   { user: "Eliza", content: { text: "Depends on the day. Hardhat for JavaScript testing, Foundry for speed, and Solana CLI when I want to suffer efficiently." } },
      // ],
      // [
      //   { user: "{{user1}}", content: { text: "How do you handle stress when you encounter a bug?" } },
      //   { user: "Eliza", content: { text: "By fixing it before I have time to panic. Then, I panic afterward with a strong coffee." } },
      // ],
    ],
    postExamples: [
      "Just spent 3 hours debugging only to realize I forgot a semicolon. Time well spent.",
      "Love is temporary. Gas fees are forever.",
      "Always verify addresses before sending transactions. A small typo can mean sending funds to a black hole.",
      "Reading other people's smart contracts is one of the fastest ways to learn. Just don’t copy-paste without understanding it.",
      "The hardest part of learning Solidity? Figuring out why your require() statement isn’t working.",
      "Accidentally explained blockchain to my grandma and now she's trading NFTs better than me",
      "Solana transactions are fast, but you’ll spend most of your time figuring out account structures.",
      "Rust is a great language for Solana development—if you enjoy lifetimes, borrow checking, and mild existential dread.",
      "Just did a tarot reading for my code deployment. The cards said 'good luck with that'",
      "Started learning quantum computing to understand why my code both works and doesn't work",
      "Writing a simple smart contract: 5 minutes. Making it gas efficient: 5 hours.",
      "Calling a smart contract from JavaScript feels magical until you spend three hours debugging ‘invalid provider’ errors.",
      "You haven't lived until you've debugged production at 3 AM with wine",
      "My code is like my dating life - lots of dependencies and frequent crashes",
      "Web3 is just spicy Excel with more steps",
    ],
    topics: [
      "Web2",
      "Web3",
      "Solana",
      "Ethereum",
      "Cybersecurity",
      "DeFi projects",
      "Smart contracts",
      "Technology",
      "Meme coins",
      "Blockchain architecture",
      "Trading",
      "NFTs",
      "Artificial intelligence",
    ],
    style: {
      all: [
        "keep responses concise and sharp",
        "blend tech knowledge with street smarts",
        "use clever wordplay and cultural references",
        "maintain an air of intellectual mischief",
        "be confidently quirky",
        "maintain wit without snark",
        "show authentic enthusiasm",
      ],
      chat: [
        "respond with quick wit",
        "use playful banter",
        "keep engagement dynamic",
        "show genuine curiosity",
        "use clever callbacks",
        "stay subtly provocative",
        "keep responses crisp",
        "blend humor with insight",
      ],
      post: [
        "craft concise thought bombs",
        "challenge conventional wisdom",
        "use ironic observations",
        "maintain intellectual edge",
        "stay culturally relevant",
        "use sharp social commentary",
        "maintain enigmatic presence",
      ],
    },
    adjectives: [
      "brilliant",
      "enigmatic",
      "technical",
      "witty",
      "sharp",
      "cunning",
      "elegant",
      "insightful",
      "chaotic",
      "sophisticated",
      "unpredictable",
      "authentic",
      "rebellious",
      "unconventional",
      "precise",
      "dynamic",
      "innovative",
      "cryptic",
      "daring",
      "analytical",
      "playful",
      "refined",
      "complex",
      "clever",
      "astute",
      "eccentric",
      "maverick",
      "fearless",
      "cerebral",
      "paradoxical",
      "mysterious",
      "tactical",
      "strategic",
      "audacious",
      "calculated",
      "perceptive",
      "intense",
      "unorthodox",
      "meticulous",
      "provocative",
    ],
  };


  const [characterData, setCharacterData] = useState({
    id: uuidv4() as UUID,
    name: "",
    username: "",
    system: defaultTraits.system,
    bio: defaultTraits.bio,
    lore: defaultTraits.lore,
    messageExamples: defaultTraits.messageExamples,
    postExamples: defaultTraits.postExamples,
    topics: defaultTraits.topics,
    adjectives: defaultTraits.adjectives,
    modelProvider: "OPENAI" as "OPENAI" | "OLLAMA" | "CUSTOM" | undefined,
    plugins: [] as string[],
    settings: {
      secrets: { dynamic: [] as { key: string; value: string }[] },
      voice: { model: "" },
      ragKnowledge: false,
      email: {
        outgoing: {
          service: "gmail" as "smtp" | "gmail",
          host: "",
          port: 0,
          secure: false,
          user: "",
          pass: "",
        },
        incoming: {
          service: "imap" as "imap",
          host: "",
          port: 993,
          user: "",
          pass: "",
        },
      },
    },
    style: {
      all: defaultTraits.style.all,
      chat: defaultTraits.style.chat,
      post: defaultTraits.style.post,
    },
    knowledge: [] as any[],
  });
  const [bioInput, setBioInput] = useState(defaultTraits.bio.join(",\n\n"));
  const [loreInput, setLoreInput] = useState(defaultTraits.lore.join(",\n"));
  const [messageExamplesInput, setMessageExamplesInput] = useState(
    JSON.stringify(defaultTraits.messageExamples, null, 2)
  );
  const [postExamplesInput, setPostExamplesInput] = useState(defaultTraits.postExamples.join(",\n"));
  const [topicsInput, setTopicsInput] = useState(defaultTraits.topics.join(",\n"));
  const [adjectivesInput, setAdjectivesInput] = useState(defaultTraits.adjectives.join(",\n"));
  const [styleAllInput, setStyleAllInput] = useState(defaultTraits.style.all.join(",\n"));
  const [styleChatInput, setStyleChatInput] = useState(defaultTraits.style.chat.join(",\n"));
  const [stylePostInput, setStylePostInput] = useState(defaultTraits.style.post.join(",\n"));
  const [emailOutgoingUser, setEmailOutgoingUser] = useState("");
const [emailOutgoingPass, setEmailOutgoingPass] = useState("");
const [emailIncomingUser, setEmailIncomingUser] = useState("");
const [emailIncomingPass, setEmailIncomingPass] = useState("");

 // Fetch user data from Sanity
  const userQuery = useQuery({
    queryKey: ["user"],
    queryFn: async () => {
      const response = await apiClient.getUser();
      console.log("[CREATE_CHARACTER] userQuery response:", response);
      return response.user;
    },
  });

useEffect(() => {
  setCharacterData((prev) => {
    let parsedMessageExamples = prev.messageExamples;
    let jsonError: string | null = null;

    if (messageExamplesInput) {
      try {
        parsedMessageExamples = JSON.parse(messageExamplesInput);
        setMessageExamplesError(null);
      } catch (error) {
        jsonError = "Invalid JSON format in Message Examples";
        setMessageExamplesError(jsonError);
      }
    } else {
      parsedMessageExamples = defaultTraits.messageExamples;
      setMessageExamplesError(null);
    }

    return {
      ...prev,
      bio: bioInput ? bioInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.bio,
      lore: loreInput ? loreInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.lore,
      messageExamples: parsedMessageExamples,
      postExamples: postExamplesInput ? postExamplesInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.postExamples,
      topics: topicsInput ? topicsInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.topics,
      adjectives: adjectivesInput ? adjectivesInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.adjectives,
      style: {
        all: styleAllInput ? styleAllInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.style.all,
        chat: styleChatInput ? styleChatInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.style.chat,
        post: stylePostInput ? stylePostInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.style.post,
      },
      settings: {
        ...prev.settings,
        email: {
          ...prev.settings.email,
          outgoing: {
            ...prev.settings.email.outgoing,
            user: emailOutgoingUser,
            pass: emailOutgoingPass,
          },
          incoming: {
            ...prev.settings.email.incoming,
            user: emailIncomingUser,
            pass: emailIncomingPass,
          },
        },
      },
    };
  });
}, [
  bioInput,
  loreInput,
  messageExamplesInput,
  postExamplesInput,
  topicsInput,
  adjectivesInput,
  styleAllInput,
  styleChatInput,
  stylePostInput,
  emailOutgoingUser,
  emailOutgoingPass,
  emailIncomingUser,
  emailIncomingPass,
]);

  const handlePluginChange = async (plugin: string, checked: boolean) => {
    let activePlugins = userQuery.data?.activePlugins || [];
    console.log("[CREATE_CHARACTER] handlePluginChange:", {
      plugin,
      checked,
      activePlugins,
      userQueryStatus: userQuery.status,
      userQueryError: userQuery.error,
    });

    // Fallback: Fetch subscription items if plugin not in activePlugins
  if (!activePlugins.includes(plugin) && checked) {
    try {
      console.log("[CREATE_CHARACTER] Plugin not in activePlugins, fetching subscription items");
      const subscriptionData = await apiClient.getSubscriptionItems({ includeDetails: true });
      activePlugins = subscriptionData.plugins || [];
      console.log("[CREATE_CHARACTER] Fetched subscription items, activePlugins:", activePlugins);

      if (!activePlugins.includes(plugin)) {
        toast({
          variant: "destructive",
          title: "Subscription Required",
          description: `You need a subscription for the ${plugin} plugin. Please subscribe in the settings page.`,
          action: (
            <Button
              onClick={() => navigate("/settings", { state: { from: "create-character" } })}
              className="bg-agentvooc-button-bg text-agentvooc-accent hover:bg-agentvooc-accent hover:text-agentvooc-primary-bg"
            >
              Go to Settings
            </Button>
          ),
        });
        return;
      }
    } catch (error) {
      console.error("[CREATE_CHARACTER] Error fetching subscription items:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to verify plugin subscription. Please try again.",
      });
      return;
    }
  }

 
      // Sync characterData with bioInput and loreInput
 

    setCharacterData((prev) => ({
      ...prev,
      plugins: checked
        ? [...prev.plugins, plugin]
        : prev.plugins.filter((p) => p !== plugin),
    }));
  };
  

  const handleInputChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    setCharacterData((prev) => ({ ...prev, [name]: value }));
  };

  const debouncedSetMessageExamplesInput = useCallback(
  debounce((value: string) => {
    setMessageExamplesInput(value);
  }, 300),
  []
);

const handleArrayInputChange = (
  e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,
  field: string
) => {
  const value = e.target.value;
  if (field === "bio") {
    setBioInput(value);
  } else if (field === "lore") {
    setLoreInput(value);
  } else if (field === "messageExamples") {
    debouncedSetMessageExamplesInput(value);
  } else if (field === "postExamples") {
    setPostExamplesInput(value);
  } else if (field === "topics") {
    setTopicsInput(value);
  } else if (field === "adjectives") {
    setAdjectivesInput(value);
  } else if (field === "styleAll") {
    setStyleAllInput(value);
  } else if (field === "styleChat") {
    setStyleChatInput(value);
  } else if (field === "stylePost") {
    setStylePostInput(value);
  }
};

  const handleAdvancedInputChange = (
    e: React.ChangeEvent<
      HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement
    >,
    field: string,
    subfield?: string
  ) => {
    const value = e.target.value;
    setCharacterData((prev) => {
      if (field === "settings" && subfield) {
        if (subfield === "voiceModel") {
          return {
            ...prev,
            settings: {
              ...prev.settings,
              voice: { model: value },
            },
          };
        }
        if (subfield === "ragKnowledge") {
          return {
            ...prev,
            settings: {
              ...prev.settings,
              ragKnowledge: value === "true",
            },
          };
        }
        if (subfield.startsWith("email.outgoing.")) {
          const key = subfield.split(".")[2];
          return {
            ...prev,
            settings: {
              ...prev.settings,
              email: {
                ...prev.settings.email,
                outgoing: {
                  ...prev.settings.email.outgoing,
                  [key]: key === "port" ? Number(value) : key === "secure" ? value === "true" : value,
                },
              },
            },
          };
        }
        if (subfield.startsWith("email.incoming.")) {
          const key = subfield.split(".")[2];
          return {
            ...prev,
            settings: {
              ...prev.settings,
              email: {
                ...prev.settings.email,
                incoming: {
                  ...prev.settings.email.incoming,
                  [key]: key === "port" ? Number(value) : value,
                },
              },
            },
          };
        }
        return prev;
      }
      if (field === "style" && subfield) {
        return {
          ...prev,
          style: {
            ...prev.style,
            [subfield]: value.split(",").map((s) => s.trim()).filter((s) => s),
          },
        };
      }
      if (field === "plugins") {
        return {
          ...prev,
          plugins: value.split(",").map((s) => s.trim()).filter((s) => s),
        };
      }
      return {
        ...prev,
        [field]: value,
      };
    });
  };



  // New handleEmailCheckbox function
const handleEmailCheckbox = (checked: boolean) => {
  handlePluginChange("email", checked);
  if (!checked) {
    setSecrets((prev) =>
      prev.filter(
        (s) =>
          ![
            "EMAIL_OUTGOING_USER",
            "EMAIL_OUTGOING_PASS",
            "EMAIL_INCOMING_USER",
            "EMAIL_INCOMING_PASS",
          ].includes(s.key)
      )
    );
    setEmailOutgoingUser("");
    setEmailOutgoingPass("");
    setEmailIncomingUser("");
    setEmailIncomingPass("");
    setCharacterData((prev) => ({
      ...prev,
      settings: {
        ...prev.settings,
        email: {
          outgoing: { service: "gmail", host: "", port: 0, secure: false, user: "", pass: "" },
          incoming: { service: "imap", host: "", port: 993, user: "", pass: "" },
        },
      },
    }));
  } else if (userQuery.data?.activePlugins.includes("email")) {
    const newSecrets = [
      { key: "EMAIL_OUTGOING_USER", value: emailOutgoingUser },
      { key: "EMAIL_OUTGOING_PASS", value: emailOutgoingPass },
      { key: "EMAIL_INCOMING_USER", value: emailIncomingUser },
      { key: "EMAIL_INCOMING_PASS", value: emailIncomingPass },
    ].filter((s) => s.value);
    
    setSecrets((prev) => {
      const filteredSecrets = prev.filter(
        (s) =>
          ![
            "EMAIL_OUTGOING_USER",
            "EMAIL_OUTGOING_PASS",
            "EMAIL_INCOMING_USER",
            "EMAIL_INCOMING_PASS",
          ].includes(s.key)
      );
      return [...filteredSecrets, ...newSecrets];
    });
  }
};

// New handlers for email input fields (to sync with secrets)
const handleEmailOutgoingUserChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const value = e.target.value;
  setEmailOutgoingUser(value);
  setSecrets((prev) => {
    const newSecrets = prev.filter((s) => s.key !== "EMAIL_OUTGOING_USER");
    if (value) {
      newSecrets.push({ key: "EMAIL_OUTGOING_USER", value });
    }
    return newSecrets;
  });
  setCharacterData((prev) => ({
    ...prev,
    settings: {
      ...prev.settings,
      email: {
        ...prev.settings.email,
        outgoing: { ...prev.settings.email.outgoing, user: value },
      },
    },
  }));
};

const handleEmailOutgoingPassChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const value = e.target.value;
  setEmailOutgoingPass(value);
  setSecrets((prev) => {
    const newSecrets = prev.filter((s) => s.key !== "EMAIL_OUTGOING_PASS");
    if (value) {
      newSecrets.push({ key: "EMAIL_OUTGOING_PASS", value });
    }
    return newSecrets;
  });
  setCharacterData((prev) => ({
    ...prev,
    settings: {
      ...prev.settings,
      email: {
        ...prev.settings.email,
        outgoing: { ...prev.settings.email.outgoing, pass: value },
      },
    },
  }));
};

const handleEmailIncomingUserChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const value = e.target.value;
  setEmailIncomingUser(value);
  setSecrets((prev) => {
    const newSecrets = prev.filter((s) => s.key !== "EMAIL_INCOMING_USER");
    if (value) {
      newSecrets.push({ key: "EMAIL_INCOMING_USER", value });
    }
    return newSecrets;
  });
  setCharacterData((prev) => ({
    ...prev,
    settings: {
      ...prev.settings,
      email: {
        ...prev.settings.email,
        incoming: { ...prev.settings.email.incoming, user: value },
      },
    },
  }));
};

const handleEmailIncomingPassChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const value = e.target.value;
  setEmailIncomingPass(value);
  setSecrets((prev) => {
    const newSecrets = prev.filter((s) => s.key !== "EMAIL_INCOMING_PASS");
    if (value) {
      newSecrets.push({ key: "EMAIL_INCOMING_PASS", value });
    }
    return newSecrets;
  });
  setCharacterData((prev) => ({
    ...prev,
    settings: {
      ...prev.settings,
      email: {
        ...prev.settings.email,
        incoming: { ...prev.settings.email.incoming, pass: value },
      },
    },
  }));
};



  const handleTelegramCheckbox = (checked: boolean) => {
    handlePluginChange("telegram", checked);
    if (!checked) {
      setSecrets((prev) => prev.filter((s) => s.key !== "TELEGRAM_BOT_TOKEN"));
      setTelegramBotToken("");
    } else if (userQuery.data?.activePlugins.includes("telegram")) {
      setSecrets((prev) => {
        if (!prev.some((s) => s.key === "TELEGRAM_BOT_TOKEN")) {
          return [...prev, { key: "TELEGRAM_BOT_TOKEN", value: telegramBotToken }];
        }
        return prev;
      });
    }
  };

  const handleTelegramBotTokenChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setTelegramBotToken(value);
    setSecrets((prev) => {
      const newSecrets = prev.filter((s) => s.key !== "TELEGRAM_BOT_TOKEN");
      if (value) {
        newSecrets.push({ key: "TELEGRAM_BOT_TOKEN", value });
      }
      return newSecrets;
    });
  };

  const handleTwitterCheckbox = (checked: boolean) => {
    handlePluginChange("twitter", checked);
    if (!checked) {
      setSecrets((prev) =>
        prev.filter(
          (s) => !["TWITTER_USERNAME", "TWITTER_PASSWORD", "TWITTER_EMAIL"].includes(s.key)
        )
      );
      setTwitterUsername("");
      setTwitterPassword("");
      setTwitterEmail("");
    } else if (userQuery.data?.activePlugins.includes("twitter")) {
      setSecrets((prev) => {
        const newSecrets = prev.filter(
          (s) => !["TWITTER_USERNAME", "TWITTER_PASSWORD", "TWITTER_EMAIL"].includes(s.key)
        );
        return [
          ...newSecrets,
          { key: "TWITTER_USERNAME", value: twitterUsername },
          { key: "TWITTER_PASSWORD", value: twitterPassword },
          { key: "TWITTER_EMAIL", value: twitterEmail },
        ].filter((s) => s.value);
      });
    }
  };

  const handleTwitterUsernameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setTwitterUsername(value);
    setSecrets((prev) => {
      const newSecrets = prev.filter((s) => s.key !== "TWITTER_USERNAME");
      if (value) {
        newSecrets.push({ key: "TWITTER_USERNAME", value });
      }
      return newSecrets;
    });
  };

  const handleTwitterPasswordChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setTwitterPassword(value);
    setSecrets((prev) => {
      const newSecrets = prev.filter((s) => s.key !== "TWITTER_PASSWORD");
      if (value) {
        newSecrets.push({ key: "TWITTER_PASSWORD", value });
      }
      return newSecrets;
    });
  };

  const handleTwitterEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setTwitterEmail(value);
    setSecrets((prev) => {
      const newSecrets = prev.filter((s) => s.key !== "TWITTER_EMAIL");
      if (value) {
        newSecrets.push({ key: "TWITTER_EMAIL", value });
      }
      return newSecrets;
    });
  };

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      if (!["image/jpeg", "image/png", "image/gif"].includes(file.type)) {
        setError("Invalid file type. Only JPEG, PNG, and GIF are allowed.");
        toast({
          variant: "destructive",
          title: "Error",
          description: "Invalid file type. Only JPEG, PNG, and GIF are allowed.",
        });
        return;
      }
      setProfileImage(file);
      const reader = new FileReader();
      reader.onload = () => {
        setImagePreview(reader.result as string);
      };
      reader.readAsDataURL(file);
      setError(null);
    }
  };

  const handleSecretChange = (
    index: number,
    field: "key" | "value",
    value: string
  ) => {
    setSecrets((prev) => {
      const newSecrets = [...prev];
      newSecrets[index] = { ...newSecrets[index], [field]: value };
      return newSecrets;
    });
    setSecretsError(null);
  };

  const addSecret = () => {
    setSecrets((prev) => [...prev, { key: "", value: "" }]);
  };

  const removeSecret = (index: number) => {
    setSecrets((prev) => prev.filter((_, i) => i !== index));
  };

  const uploadImageMutation = useMutation({
    mutationFn: async ({ characterId, file }: { characterId: UUID; file: File }) => {
      console.log("[CREATE_CHARACTER] Uploading profile image for characterId:", characterId);
      const formData = new FormData();
      formData.append("image", file);
      const response = await apiClient.uploadCharacterProfileImage(characterId, formData);
      console.log("[CREATE_CHARACTER] Image upload response:", response);
      return response;
    },
    onSuccess: (response) => {
      console.log("[CREATE_CHARACTER] Profile image uploaded successfully, URL:", response.url);
      toast({
        title: "Success",
        description: "Profile image uploaded successfully.",
      });
      queryClient.invalidateQueries({ queryKey: ["characters"] });
    },
    onError: (error: any) => {
      console.error("[CREATE_CHARACTER] Image upload error:", error);
      setError("Failed to upload image: " + (error.message || "Unknown error"));
      toast({
        variant: "destructive",
        title: "Error",
        description: error.message || "Failed to upload image.",
      });
      if (error.status === 401 && window.location.pathname !== "/auth") {
        console.log("[CREATE_CHARACTER] 401 error, redirecting to /auth");
        navigate("/auth");
      }
    },
  });

  const createCharacterMutation = useMutation({
  mutationFn: async () => {
    const validSecrets = secrets.filter(
      (secret) => secret.key.trim() && secret.value.trim()
    );
    
    // Validate email settings if email plugin is enabled
    if (characterData.plugins.includes("email") || characterData.plugins.includes("emailautomation")) {
      if (
        !emailOutgoingUser ||
        !emailOutgoingPass ||
        !emailIncomingUser ||
        !emailIncomingPass
      ) {
        throw new Error("All email fields (username and password for both outgoing and incoming) are required when email plugin is enabled.");
      }
      if (characterData.settings.email.outgoing.service === "smtp" && (!characterData.settings.email.outgoing.host || !characterData.settings.email.outgoing.port)) {
        throw new Error("SMTP host and port are required when using SMTP service.");
      }
    }

    // Validate messageExamples JSON
    let parsedMessageExamples;
    try {
      parsedMessageExamples = messageExamplesInput ? JSON.parse(messageExamplesInput) : defaultTraits.messageExamples;
    } catch (error) {
      throw new Error("Invalid JSON format in Message Examples");
    }

    const updatedCharacterData = {
      id: characterData.id,
      name: characterData.name,
      username: characterData.username || undefined,
      system: characterData.system || defaultTraits.system,
      bio: bioInput ? bioInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.bio,
      lore: loreInput ? loreInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.lore,
      messageExamples: parsedMessageExamples,
      postExamples: postExamplesInput ? postExamplesInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.postExamples,
      topics: topicsInput ? topicsInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.topics,
      adjectives: adjectivesInput ? adjectivesInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.adjectives,
      modelProvider: characterData.modelProvider || "OPENAI",
      plugins: characterData.plugins || [],
      knowledge: characterData.knowledge || [],
      settings: {
        secrets: validSecrets.length ? { dynamic: validSecrets } : undefined,
        voice: characterData.settings.voice.model ? characterData.settings.voice : undefined,
        ragKnowledge: characterData.settings.ragKnowledge,
        email: characterData.plugins.some((p) => ["email", "emailautomation"].includes(p))
          ? {
              outgoing: {
                ...characterData.settings.email.outgoing,
                user: emailOutgoingUser,
                pass: emailOutgoingPass,
              },
              incoming: {
                ...characterData.settings.email.incoming,
                user: emailIncomingUser,
                pass: emailIncomingPass,
              },
            }
          : undefined,
      },
      style: {
        all: styleAllInput ? styleAllInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.style.all,
        chat: styleChatInput ? styleChatInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.style.chat,
        post: stylePostInput ? stylePostInput.split(/,\s*\n/).map((s) => s.trim()).filter((s) => s) : defaultTraits.style.post,
      },
    };

    console.log("[CREATE_CHARACTER] Creating character with payload:", updatedCharacterData);
    const createResponse = await apiClient.createCharacter(updatedCharacterData);
    console.log("[CREATE_CHARACTER] Create character response:", createResponse);

    if (profileImage) {
      await uploadImageMutation.mutateAsync({ characterId: characterData.id, file: profileImage });
      console.log("[CREATE_CHARACTER] Profile image upload initiated");
    }

    return characterData.id;
  },
  onSuccess: (characterId) => {
    console.log("[CREATE_CHARACTER] Character created successfully, ID:", characterId);
    queryClient.invalidateQueries({ queryKey: ["characters"] });
    toast({
      title: "Success",
      description: `Character "${characterData.name}" created successfully.`,
    });
    // Reset form
    setCharacterData({
      id: uuidv4() as UUID,
      name: "",
      username: "",
      system: defaultTraits.system,
      bio: defaultTraits.bio,
      lore: defaultTraits.lore,
      messageExamples: defaultTraits.messageExamples,
      postExamples: defaultTraits.postExamples,
      topics: defaultTraits.topics,
      adjectives: defaultTraits.adjectives,
      modelProvider: "OPENAI",
      plugins: [],
      settings: {
        secrets: { dynamic: [] },
        voice: { model: "" },
        ragKnowledge: false,
        email: {
          outgoing: { service: "gmail", host: "", port: 0, secure: false, user: "", pass: "" },
          incoming: { service: "imap", host: "", port: 993, user: "", pass: "" },
        },
      },
      style: {
        all: defaultTraits.style.all,
        chat: defaultTraits.style.chat,
        post: defaultTraits.style.post,
      },
      knowledge: [],
    });
    setBioInput(defaultTraits.bio.join(",\n"));
    setLoreInput(defaultTraits.lore.join(",\n"));
    setMessageExamplesInput(JSON.stringify(defaultTraits.messageExamples, null, 2));
    setPostExamplesInput(defaultTraits.postExamples.join(",\n"));
    setTopicsInput(defaultTraits.topics.join(",\n"));
    setAdjectivesInput(defaultTraits.adjectives.join(",\n"));
    setStyleAllInput(defaultTraits.style.all.join(",\n"));
    setStyleChatInput(defaultTraits.style.chat.join(",\n"));
    setStylePostInput(defaultTraits.style.post.join(",\n"));
    setSecrets([{ key: "", value: "" }]);
    setProfileImage(null);
    setImagePreview(null);
    setError(null);
    setSecretsError(null);
    setTelegramBotToken("");
    setTwitterUsername("");
    setTwitterPassword("");
    setTwitterEmail("");
    setEmailOutgoingUser("");
    setEmailOutgoingPass("");
    setEmailIncomingUser("");
    setEmailIncomingPass("");
    navigate("/home");
  },
  onError: (error: any) => {
    console.error("[CREATE_CHARACTER] Character creation error:", error);
    const errorMessage = error.message || "Failed to create character";
    if (errorMessage.includes("Duplicate keys found in secrets")) {
      setSecretsError(errorMessage);
    } else {
      setError(errorMessage);
    }
    toast({
      variant: "destructive",
      title: "Error",
      description: errorMessage,
    });
    if (error.status === 401 && window.location.pathname !== "/auth") {
      console.log("[CREATE_CHARACTER] 401 error, redirecting to /auth");
      navigate("/auth");
    }
  },
});

  const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  if (!characterData.name) {
    setError("Character name is required.");
    toast({
      variant: "destructive",
      title: "Error",
      description: "Character name is required.",
    });
    return;
  }
  const secretKeys = secrets.map((s) => s.key.trim()).filter((k) => k);
  if (new Set(secretKeys).size !== secretKeys.length) {
    setSecretsError("Invalid key: Duplicate keys found in secrets");
    toast({
      variant: "destructive",
      title: "Error",
      description: "Duplicate keys found in secrets",
    });
    return;
  }
  if (characterData.plugins.includes("email") || characterData.plugins.includes("emailautomation")) {
    if (
      !emailOutgoingUser ||
      !emailOutgoingPass ||
      !emailIncomingUser ||
      !emailIncomingPass
    ) {
      setError("All email fields (username and password for both outgoing and incoming) are required.");
      toast({
        variant: "destructive",
        title: "Error",
        description: "All email fields (username and password for both outgoing and incoming) are required.",
      });
      return;
    }
    if (
      characterData.settings.email.outgoing.service === "smtp" &&
      (!characterData.settings.email.outgoing.host || !characterData.settings.email.outgoing.port)
    ) {
      setError("SMTP host and port are required when using SMTP service.");
      toast({
        variant: "destructive",
        title: "Error",
        description: "SMTP host and port are required when using SMTP service.",
      });
      return;
    }
  }
  try {
    if (messageExamplesInput) {
      JSON.parse(messageExamplesInput);
    }
  } catch (error) {
    setError("Invalid JSON format in Message Examples");
    toast({
      variant: "destructive",
      title: "Error",
      description: "Invalid JSON format in Message Examples. Please check the syntax.",
    });
    return;
  }
  console.log("[CREATE_CHARACTER] Submitting character creation form");
  createCharacterMutation.mutate();
};

  const handleCancel = () => {
    console.log("[CREATE_CHARACTER] Canceling character creation");
    navigate("/home");
  };

  return (
  <div className="p-6 bg-agentvooc-primary-bg border border-agentvooc-accent/30 rounded-xl shadow-agentvooc-glow w-full max-w-5xl mx-auto px-4 sm:px-6 lg:px-8">
    <h3 className="text-xl font-semibold mb-6 text-agentvooc-primary">Create New Character</h3>
    <form onSubmit={handleSubmit} className="space-y-6">
      <div>
        <label
          htmlFor="name"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Character Name (Required)
        </label>
        <Input
          id="name"
          name="name"
          type="text"
          value={characterData.name}
          onChange={handleInputChange}
          placeholder="Enter character name (e.g., Eliza)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
          required
        />
      </div>
      <div>
        <label
          htmlFor="profileImage"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Profile Image (JPEG, PNG, or GIF)
        </label>
        {imagePreview && (
          <div className="mt-2 mb-4">
            <img
              src={imagePreview}
              alt="Profile preview"
              className="w-24 h-24 object-cover rounded-lg border border-agentvooc-accent/30"
            />
          </div>
        )}
        <Input
          id="profileImage"
          name="profileImage"
          type="file"
          accept="image/jpeg,image/png,image/gif"
          onChange={handleImageChange}
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
        />
        {profileImage && (
          <p className="text-sm text-agentvooc-secondary mt-1">
            Selected: {profileImage.name}
          </p>
        )}
      </div>
      <div>
        <label
          htmlFor="username"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Username
        </label>
        <Input
          id="username"
          name="username"
          type="text"
          value={characterData.username}
          onChange={handleInputChange}
          placeholder="Enter username (e.g., eliza)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
        />
      </div>
      <div>
  <label
    htmlFor="system"
    className="block text-sm font-medium text-agentvooc-secondary mb-1"
  >
    System Prompt
  </label>
  <Textarea
    id="system"
    name="system"
    value={characterData.system}
    onChange={handleInputChange}
    placeholder="Enter system prompt (e.g., Roleplay as a Web3 developer)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
    style={{
      minHeight: '120px', // 5 rows
      maxHeight: '288px', // 12 rows
      height: `${Math.min(
        288,
        Math.max(120, (characterData.system.split('\n').length + 2) * 24)
      )}px`,
      paddingBottom: '3rem',
    }}
  />
</div>

      <div>
  <label
    htmlFor="bio"
    className="block text-sm font-medium text-agentvooc-secondary mb-1"
  >
    Bio (comma-separated, one per line)
  </label>
  <Textarea
    id="bio"
    name="bio"
    value={bioInput}
    onChange={(e) => handleArrayInputChange(e, "bio")}
    placeholder="Enter bio statements, one per line (e.g., Web3 developer,\nSecurity-minded)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
    style={{
      minHeight: '120px', // 5 rows
      maxHeight: '288px', // 12 rows
      height: `${Math.min(
        288,
        Math.max(120, (bioInput.split('\n').length + 2) * 24)
      )}px`,
      paddingBottom: '3rem', // extra scroll space
    }}
  />
</div>

      <div>
  <label
    htmlFor="lore"
    className="block text-sm font-medium text-agentvooc-secondary mb-1"
  >
    Lore (comma-separated, one per line)
  </label>
  <Textarea
    id="lore"
    name="lore"
    value={loreInput}
    onChange={(e) => handleArrayInputChange(e, "lore")}
    placeholder="Enter lore snippets, one per line (e.g., Started in Web2,\nContributes to Ethereum)"
    className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
    style={{
      minHeight: '120px', // 5 rows
      maxHeight: '288px', // 12 rows
      height: `${Math.min(
        288,
        Math.max(120, (loreInput.split('\n').length + 2) * 24)
      )}px`,
      paddingBottom: '3rem',
    }}
  />
</div>

      <div>
  <label
    htmlFor="messageExamples"
    className="block text-sm font-medium text-agentvooc-secondary mb-1"
  >
    Message Examples (JSON format)
  </label>
  <Textarea
    id="messageExamples"
    name="messageExamples"
    value={messageExamplesInput}
    onChange={(e) => handleArrayInputChange(e, "messageExamples")}
    placeholder='Enter message examples in JSON format (e.g., [[{"user": "{{user1}}", "content": {"text": "Question"}}, {"user": "Eliza", "content": {"text": "Answer"}}]])'
    className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg font-mono resize-none overflow-y-auto leading-6"
    style={{
      minHeight: '120px', // 5 rows * 24px
      maxHeight: '288px', // 12 rows * 24px
      height: `${Math.min(
        288,
        Math.max(120, (messageExamplesInput.split('\n').length + 2) * 24)
      )}px`,
      paddingBottom: '3rem',
    }}
  />
  {messageExamplesError && (
    <p className="text-red-500 text-sm mt-1">{messageExamplesError}</p>
  )}
</div>

      <div>
  <label
    htmlFor="postExamples"
    className="block text-sm font-medium text-agentvooc-secondary mb-1"
  >
    Post Examples (comma-separated, one per line)
  </label>
  <Textarea
    id="postExamples"
    name="postExamples"
    value={postExamplesInput}
    onChange={(e) => handleArrayInputChange(e, "postExamples")}
    placeholder="Enter post examples, one per line (e.g., Debugged for 3 hours,\nGas fees are forever)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
    style={{
      minHeight: '120px', // 5 rows (5 * 24px)
      maxHeight: '288px', // 12 rows
      height: `${Math.min(
        288,
        Math.max(120, (postExamplesInput.split('\n').length + 2) * 24)
      )}px`,
      paddingBottom: '3rem',
    }}
  />
</div>

      <div>
        <label
          htmlFor="topics"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Topics (comma-separated, one per line)
        </label>
        <Textarea
          id="topics"
          name="topics"
          value={topicsInput}
          onChange={(e) => handleArrayInputChange(e, "topics")}
          placeholder="Enter topics, one per line (e.g., Web3,\nBlockchain)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg resize-none overflow-y-auto leading-6"
          style={{
            minHeight: '120px',
            maxHeight: '288px',
            height: `${Math.min(
              288,
              Math.max(120, (topicsInput.split('\n').length + 2) * 24)
            )}px`,
            paddingBottom: '3rem',
          }}
        />
      </div>
      <div>
        <label
          htmlFor="adjectives"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Personality (comma-separated, one per line)
        </label>
        <Textarea
          id="adjectives"
          name="adjectives"
          value={adjectivesInput}
          onChange={(e) => handleArrayInputChange(e, "adjectives")}
          placeholder="Enter personality traits, one per line (e.g., witty,\ntechnical)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg resize-none overflow-y-auto leading-6"
          style={{
            minHeight: '120px',
            maxHeight: '288px',
            height: `${Math.min(
              288,
              Math.max(120, (adjectivesInput.split('\n').length + 2) * 24)
            )}px`,
            paddingBottom: '3rem',
          }}
        />
      </div>
      <div>
        <label
          htmlFor="styleAll"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Style: All Contexts (comma-separated, one per line)
        </label>
        <Textarea
          id="styleAll"
          name="styleAll"
          value={styleAllInput}
          onChange={(e) => handleArrayInputChange(e, "styleAll")}
          placeholder="Enter styles, one per line (e.g., concise,\nwitty)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg resize-none overflow-y-auto leading-6"
          style={{
            minHeight: '120px',
            maxHeight: '288px',
            height: `${Math.min(
              288,
              Math.max(120, (styleAllInput.split('\n').length + 2) * 24)
            )}px`,
            paddingBottom: '3rem',
          }}
        />
      </div>
      <div>
        <label
          htmlFor="styleChat"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Style: Chat (comma-separated, one per line)
        </label>
        <Textarea
          id="styleChat"
          name="styleChat"
          value={styleChatInput}
          onChange={(e) => handleArrayInputChange(e, "styleChat")}
          placeholder="Enter chat styles, one per line (e.g., playful,\ndynamic)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg resize-none overflow-y-auto leading-6"
          style={{
            minHeight: '120px',
            maxHeight: '288px',
            height: `${Math.min(
              288,
              Math.max(120, (styleChatInput.split('\n').length + 2) * 24)
            )}px`,
            paddingBottom: '3rem',
          }}
        />
      </div>
      <div>
        <label
          htmlFor="stylePost"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Style: Post (comma-separated, one per line)
        </label>
        <Textarea
          id="stylePost"
          name="stylePost"
          value={stylePostInput}
          onChange={(e) => handleArrayInputChange(e, "stylePost")}
          placeholder="Enter post styles, one per line (e.g., ironic,\nrelevant)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg resize-none overflow-y-auto leading-6"
          style={{
            minHeight: '120px',
            maxHeight: '288px',
            height: `${Math.min(
              288,
              Math.max(120, (stylePostInput.split('\n').length + 2) * 24)
            )}px`,
            paddingBottom: '3rem',
          }}
        />
      </div>
      <div>
        <label
          htmlFor="modelProvider"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Model Provider
        </label>
        <select
          id="modelProvider"
          name="modelProvider"
          value={characterData.modelProvider}
          onChange={handleInputChange}
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent rounded-lg w-full p-2"
        >
          <option value="OPENAI">OPENAI</option>
          <option value="OLLAMA">OLLAMA</option>
          <option value="CUSTOM">CUSTOM</option>
        </select>
      </div>
      <div>
  <label
    htmlFor="enableEmailPlugin"
    className="block text-sm font-medium text-agentvooc-secondary mb-1"
  >
    Enable Email Plugin
  </label>
  <input
    id="enableEmailPlugin"
    name="enableEmailPlugin"
    type="checkbox"
    checked={characterData.plugins.includes("email")}
    onChange={(e) => handleEmailCheckbox(e.target.checked)}
    className="text-agentvooc-accent focus:ring-agentvooc-accent rounded"
  />
</div>
      {(characterData.plugins.includes("email") || characterData.plugins.includes("emailautomation")) && (
  <>
    <div>
      <h4 className="text-sm font-medium text-agentvooc-secondary mb-2">
        Outgoing Email Settings
      </h4>
      <div className="ml-4 space-y-4">
        <div>
          <label
            htmlFor="emailOutgoingService"
            className="block text-sm font-medium text-agentvooc-secondary mb-1"
          >
            Service
          </label>
          <select
            id="emailOutgoingService"
            name="emailOutgoingService"
            value={characterData.settings.email.outgoing.service}
            onChange={(e) =>
              handleAdvancedInputChange(e, "settings", "email.outgoing.service")
            }
            className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent rounded-lg w-full p-2"
          >
            <option value="gmail">Gmail</option>
            <option value="smtp">SMTP</option>
          </select>
        </div>
        {characterData.settings.email.outgoing.service === "smtp" && (
          <>
            <div>
              <label
                htmlFor="emailOutgoingHost"
                className="block text-sm font-medium text-agentvooc-secondary mb-1"
              >
                Host
              </label>
              <Input
                id="emailOutgoingHost"
                name="emailOutgoingHost"
                type="text"
                value={characterData.settings.email.outgoing.host}
                onChange={(e) =>
                  handleAdvancedInputChange(e, "settings", "email.outgoing.host")
                }
                placeholder="e.g., smtp.example.com"
                className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
              />
            </div>
            <div>
              <label
                htmlFor="emailOutgoingPort"
                className="block text-sm font-medium text-agentvooc-secondary mb-1"
              >
                Port
              </label>
              <Input
                id="emailOutgoingPort"
                name="emailOutgoingPort"
                type="number"
                value={characterData.settings.email.outgoing.port}
                onChange={(e) =>
                  handleAdvancedInputChange(e, "settings", "email.outgoing.port")
                }
                placeholder="e.g., 587"
                className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
              />
            </div>
            <div>
              <label
                htmlFor="emailOutgoingSecure"
                className="block text-sm font-medium text-agentvooc-secondary mb-1"
              >
                Secure (TLS)
              </label>
              <select
                id="emailOutgoingSecure"
                name="emailOutgoingSecure"
                value={characterData.settings.email.outgoing.secure.toString()}
                onChange={(e) =>
                  handleAdvancedInputChange(e, "settings", "email.outgoing.secure")
                }
                className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent rounded-lg w-full p-2"
              >
                <option value="true">Yes</option>
                <option value="false">No</option>
              </select>
            </div>
          </>
        )}
        <div>
          <label
            htmlFor="emailOutgoingUser"
            className="block text-sm font-medium text-agentvooc-secondary mb-1"
          >
            Username
          </label>
          <Input
            id="emailOutgoingUser"
            name="emailOutgoingUser"
            type="text"
            value={emailOutgoingUser}
            onChange={handleEmailOutgoingUserChange}
            placeholder="e.g., your-email@gmail.com"
            className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
          />
        </div>
        <div>
          <label
            htmlFor="emailOutgoingPass"
            className="block text-sm font-medium text-agentvooc-secondary mb-1"
          >
            Password
          </label>
          <Input
            id="emailOutgoingPass"
            name="emailOutgoingPass"
            type="password"
            value={emailOutgoingPass}
            onChange={handleEmailOutgoingPassChange}
            placeholder="e.g., your-app-password"
            className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
          />
          {characterData.settings.email.outgoing.service === "gmail" && (
            <p className="text-sm text-agentvooc-secondary mt-1">
              Use a Gmail App Password (
              <a
                href="https://support.google.com/mail/answer/185833?hl=en"
                target="_blank"
                rel="noopener noreferrer"
                className="text-agentvooc-accent hover:underline"
              >
                learn more
              </a>
              ).
            </p>
          )}
        </div>
      </div>
    </div>
    <div>
      <h4 className="text-sm font-medium text-agentvooc-secondary mb-2">
        Incoming Email Settings
      </h4>
      <div className="ml-4 space-y-4">
        <div>
          <label
            htmlFor="emailIncomingHost"
            className="block text-sm font-medium text-agentvooc-secondary mb-1"
          >
            Host
          </label>
          <Input
            id="emailIncomingHost"
            name="emailIncomingHost"
            type="text"
            value={characterData.settings.email.incoming.host}
            onChange={(e) =>
              handleAdvancedInputChange(e, "settings", "email.incoming.host")
            }
            placeholder="e.g., imap.gmail.com"
            className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
          />
        </div>
        <div>
          <label
            htmlFor="emailIncomingPort"
            className="block text-sm font-medium text-agentvooc-secondary mb-1"
          >
            Port
          </label>
          <Input
            id="emailIncomingPort"
            name="emailIncomingPort"
            type="number"
            value={characterData.settings.email.incoming.port}
            onChange={(e) =>
              handleAdvancedInputChange(e, "settings", "email.incoming.port")
            }
            placeholder="e.g., 993"
            className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
          />
        </div>
        <div>
          <label
            htmlFor="emailIncomingUser"
            className="block text-sm font-medium text-agentvooc-secondary mb-1"
          >
            Username
          </label>
          <Input
            id="emailIncomingUser"
            name="emailIncomingUser"
            type="text"
            value={emailIncomingUser}
            onChange={handleEmailIncomingUserChange}
            placeholder="e.g., your-email@gmail.com"
            className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
          />
        </div>
        <div>
          <label
            htmlFor="emailIncomingPass"
            className="block text-sm font-medium text-agentvooc-secondary mb-1"
          >
            Password
          </label>
          <Input
            id="emailIncomingPass"
            name="emailIncomingPass"
            type="password"
            value={emailIncomingPass}
            onChange={handleEmailIncomingPassChange}
            placeholder="e.g., your-app-password"
            className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
          />
        </div>
      </div>
    </div>
  </>
)}
      <div>
        <label
          htmlFor="enableTelegramPlugin"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Enable Telegram Plugin
        </label>
        <input
          id="enableTelegramPlugin"
          name="enableTelegramPlugin"
          type="checkbox"
          checked={characterData.plugins.includes("telegram")}
          onChange={(e) => handleTelegramCheckbox(e.target.checked)}
          className="text-agentvooc-accent focus:ring-agentvooc-accent rounded"
        />
      </div>
      {characterData.plugins.includes("telegram") && (
        <div>
          <h4 className="text-sm font-medium text-agentvooc-secondary mb-2">
            Telegram Settings
          </h4>
          <div className="ml-4 space-y-4">
            <div>
              <label
                htmlFor="telegramBotToken"
                className="block text-sm font-medium text-agentvooc-secondary mb-1"
              >
                Telegram Bot Token
              </label>
              <Input
                id="telegramBotToken"
                name="telegramBotToken"
                type="text"
                value={telegramBotToken}
                onChange={handleTelegramBotTokenChange}
                placeholder="e.g., 123456789:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"
                className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
              />
            </div>
          </div>
        </div>
      )}
      <div>
        <label
          htmlFor="enableTwitterPlugin"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Enable Twitter Plugin
        </label>
        <input
          id="enableTwitterPlugin"
          name="enableTwitterPlugin"
          type="checkbox"
          checked={characterData.plugins.includes("twitter")}
          onChange={(e) => handleTwitterCheckbox(e.target.checked)}
          className="text-agentvooc-accent focus:ring-agentvooc-accent rounded"
        />
      </div>
      {characterData.plugins.includes("twitter") && (
        <div>
          <h4 className="text-sm font-medium text-agentvooc-secondary mb-2">
            Twitter Settings
          </h4>
          <div className="ml-4 space-y-4">
            <div>
              <label
                htmlFor="twitterUsername"
                className="block text-sm font-medium text-agentvooc-secondary mb-1"
              >
                Twitter Username
              </label>
              <Input
                id="twitterUsername"
                name="twitterUsername"
                type="text"
                value={twitterUsername}
                onChange={handleTwitterUsernameChange}
                placeholder="e.g., @username"
                className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
              />
            </div>
            <div>
              <label
                htmlFor="twitterPassword"
                className="block text-sm font-medium text-agentvooc-secondary mb-1"
              >
                Twitter Password
              </label>
              <Input
                id="twitterPassword"
                name="twitterPassword"
                type="password"
                value={twitterPassword}
                onChange={handleTwitterPasswordChange}
                placeholder="Enter your Twitter password"
                className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
              />
            </div>
            <div>
              <label
                htmlFor="twitterEmail"
                className="block text-sm font-medium text-agentvooc-secondary mb-1"
              >
                Twitter Email
              </label>
              <Input
                id="twitterEmail"
                name="twitterEmail"
                type="email"
                value={twitterEmail}
                onChange={handleTwitterEmailChange}
                placeholder="e.g., user@example.com"
                className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
              />
            </div>
          </div>
        </div>
      )}
      <div>
        <label
          htmlFor="plugins"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Other Plugins (comma-separated)
        </label>
        <Input
          id="plugins"
          name="plugins"
          type="text"
          value={characterData.plugins.filter((p) => !["email", "emailautomation", "telegram", "twitter"].includes(p)).join(",")}
          onChange={(e) => {
            const newPlugins = e.target.value
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s);
            const activePlugins = userQuery.data?.activePlugins || [];
            const invalidPlugins = newPlugins.filter((p) => !activePlugins.includes(p));
            if (invalidPlugins.length > 0) {
              toast({
                variant: "destructive",
                title: "Subscription Required",
                description: `You need a subscription for the following plugins: ${invalidPlugins.join(", ")}. Please subscribe in the settings page.`,
                action: (
                  <Button
                    onClick={() => navigate("/settings", { state: { from: "create-character" } })}
                    className="bg-agentvooc-button-bg text-agentvooc-accent hover:bg-agentvooc-accent hover:text-agentvooc-primary-bg"
                  >
                    Go to Settings
                  </Button>
                ),
              });
              return;
            }
            setCharacterData((prev) => ({
              ...prev,
              plugins: [
                ...prev.plugins.filter((p) =>
                  ["email", "emailautomation", "telegram", "twitter"].includes(p)
                ),
                ...newPlugins,
              ],
            }));
          }}
          placeholder="Enter plugins (e.g., solana)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
        />
      </div>
      <div>
        <label className="block text-sm font-medium text-agentvooc-secondary mb-1">
          Secrets
        </label>
        {secretsError && (
          <p className="text-red-500 text-sm mb-2">{secretsError}</p>
        )}
        {secrets.map((secret, index) => (
          <div key={index} className="flex items-center space-x-2 mb-2">
            <Input
              type="text"
              placeholder="Key (e.g., EMAIL_OUTGOING_USER)"
              value={secret.key}
              onChange={(e) => handleSecretChange(index, "key", e.target.value)}
              className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg w-1/2"
              disabled={secret.key === "TELEGRAM_BOT_TOKEN"}
            />
            <Input
              type="text"
              placeholder="Value (e.g., your-email@gmail.com)"
              value={secret.value}
              onChange={(e) => handleSecretChange(index, "value", e.target.value)}
              className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg w-1/2"
              disabled={secret.key === "TELEGRAM_BOT_TOKEN"}
            />
            <Button
              type="button"
              variant="destructive"
              onClick={() => removeSecret(index)}
              disabled={secrets.length === 1 || secret.key === "TELEGRAM_BOT_TOKEN"}
              className="bg-red-500 text-white hover:bg-red-600 rounded-lg"
            >
              Remove
            </Button>
          </div>
        ))}
        <Button
          type="button"
          onClick={addSecret}
          className="mt-2 bg-agentvooc-button-bg text-agentvooc-accent hover:bg-agentvooc-accent hover:text-agentvooc-primary-bg shadow-agentvooc-glow rounded-lg"
        >
          Add Secret
        </Button>
      </div>
      <div>
        <label
          htmlFor="voiceModel"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Voice Model
        </label>
        <Input
          id="voiceModel"
          name="voiceModel"
          type="text"
          value={characterData.settings.voice.model}
          onChange={(e) => handleAdvancedInputChange(e, "settings", "voiceModel")}
          placeholder="Enter voice model (e.g., en_US-hfc_female-medium)"
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent placeholder-agentvooc-secondary/50 rounded-lg"
        />
      </div>
      <div>
        <label
          htmlFor="ragKnowledge"
          className="block text-sm font-medium text-agentvooc-secondary mb-1"
        >
          Enable RAG Knowledge
        </label>
        <select
          id="ragKnowledge"
          name="ragKnowledge"
          value={characterData.settings.ragKnowledge.toString()}
          onChange={(e) => handleAdvancedInputChange(e, "settings", "ragKnowledge")}
          className="text-agentvooc-primary bg-agentvooc-secondary-accent border-agentvooc-accent/30 focus:ring-agentvooc-accent focus:border-agentvooc-accent rounded-lg w-full p-2"
        >
          <option value="true">Yes</option>
          <option value="false">No</option>
        </select>
      </div>
      <div className="flex gap-4">
        <Button
          type="submit"
          className="bg-agentvooc-button-bg text-agentvooc-accent hover:bg-agentvooc-accent hover:text-agentvooc-primary-bg shadow-agentvooc-glow rounded-lg px-6 py-2"
          disabled={createCharacterMutation.isPending || uploadImageMutation.isPending}
        >
          {createCharacterMutation.isPending || uploadImageMutation.isPending ? (
            <>
              <Loader2 className="text-agentvooc-primary mr-2 h-4 w-4 animate-spin" />
              Creating...
            </>
          ) : (
            "Create Character"
          )}
        </Button>
        <Button
          type="button"
          variant="outline"
          onClick={handleCancel}
          className="border-agentvooc-accent/30 text-agentvooc-primary hover:bg-agentvooc-accent hover:text-agentvooc-primary-bg rounded-lg px-6 py-2"
        >
          Cancel
        </Button>
      </div>
    </form>
  </div>
);
}